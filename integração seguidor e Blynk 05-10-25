// Comunicação com o Blynk
#define BLYNK_TEMPLATE_ID "TMPL2J7cngmj8"
#define BLYNK_TEMPLATE_NAME "Solar traker"
#define BLYNK_AUTH_TOKEN "1qdH2QNzlCTbmP8b5mV6k3LX51o2GynA"

#define BLYNK_PRINT Serial

// Bibliotecas do Blynk e Wi-Fi
#include <WiFi.h>
#include <WiFiClient.h>
#include <BlynkSimpleEsp32.h>

// Biblioteca do Servo motor no ESP32
#include <ESP32Servo.h> 

// Nome e Senha da internet
char ssid[] = "ADRIANO_2G";
char pass[] = "21071374";

// Pino e variaveis para a leitura da Tensão, Corrente, Potência e Eficiência
#define pinLeituracorrente 34
float resistencia = 500.00;
float corrente;
float correntemAmper;
float tensao = 5.00;
float potencia;
int eficiencia;
float potenciamW;
float potenciaPico = 1.25;
int resistorShunt = 110;

// Pinos e variaveis do Seguidor Solar
int sensorSuperiorDireito = 33;
int sensorSuperiorEsquerdo = 32;
int sensorInferiorDireito = 35;
int sensorInferiorEsquerdo= 36;

Servo servox;  
int posicaoX = 180;
int limitiMaximoX = 175;
int limitiMinimoX = 5;

Servo servoy;
int posicaoY = 45;
int limitiMaximoY = 180;
int limitiMinimoY = 0;

BlynkTimer timer; // Creating a timer object

BLYNK_WRITE(V0)
{
  // Set incoming value from pin V0 to a variable
  int value = param.asInt();

  // Update state
  Blynk.virtualWrite(V1, value);
}

BLYNK_CONNECTED()
{
  // Change Web Link Button message to "Congratulations!"
  Blynk.setProperty(V3, "offImageUrl", "https://static-image.nyc3.cdn.digitaloceanspaces.com/general/fte/congratulations.png");
  Blynk.setProperty(V3, "onImageUrl",  "https://static-image.nyc3.cdn.digitaloceanspaces.com/general/fte/congratulations_pressed.png");
  Blynk.setProperty(V3, "url", "https://docs.blynk.io/en/getting-started/template-quick-setup");
}

// This function sends Arduino's uptime every second to Virtual Pin 2.
void myTimerEvent()
{
  // You can send any value at any time.
  // Please don't send more that 10 values per second.
  Blynk.virtualWrite(V2, millis() / 1000);
}

void enviandoDadosDeGeracao()
{
  Blynk.virtualWrite(V0, eficiencia);
  Blynk.virtualWrite(V1, tensao);
  Blynk.virtualWrite(V5, tensao);
  Blynk.virtualWrite(V2, correntemAmper);
  Blynk.virtualWrite(V9, correntemAmper);
}

void enviandoDadosServo()
{
  Blynk.virtualWrite(V4, posicaoX);
  Blynk.virtualWrite(V6, posicaoY);
}

void setup()
{
  Serial.begin(115200);
  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);

  // Setup a timer function to be called every second
  timer.setInterval(1000L, myTimerEvent);
  timer.setInterval(500L, enviandoDadosDeGeracao);
  timer.setInterval(500L, enviandoDadosServo);

  // Definição dos pinos dos Servos 
  servox.attach(12);
  servoy.attach(13);

  // Posição inicial dos Servo
  servox.write(180);
  servoy.write(45);
  delay(500);
  
}

void loop()
{
  Blynk.run();
  timer.run();
  calculoCorrenteTensaoPotencia();
  seguidorSolar();
  delay(10);
 
  // You can inject your own code or combine it with other sketches.
  // Check other examples on how to communicate with Blynk. Remember
  // to avoid delay() function!
}

// Função \Para fazer os Calculos de Tensão, Corrente, Potência e Eficiência
void calculoCorrenteTensaoPotencia(){
  float leituraCorrente = analogRead(pinLeituracorrente);
  //Serial.println(leitura, 10);

  float leituraCorrenteAjustada = (leituraCorrente * 3.3) / 4095.0;
  
  corrente = leituraCorrenteAjustada / resistorShunt;
  correntemAmper = corrente * 1000;

  potencia = tensao * corrente;
  potenciamW = potencia * 1000;

  eficiencia = (potencia/potenciaPico) * 100;

  //Serial.print("Corrente = ");
  //Serial.print(correntemAmper, 4);
  //Serial.print(" mA :");
  //Serial.print(" Tensão = ");
  //Serial.print(tensao, 4);
  //Serial.print(" V :");
  //Serial.print(" Potência = ");
  //Serial.print(potenciamW, 4);
  //Serial.print(" mW :");
  //Serial.print(" Eficiência = ");
  //Serial.print(eficiencia);
  //Serial.println(" %");
  //delay(500);
}

// Função do Seguidor Solar
void seguidorSolar(){
  int leituraSuperiorDireito = analogRead(sensorSuperiorDireito); 
  int leituraSuperiorEsquerdo = analogRead(sensorSuperiorEsquerdo);
  int leituraInferiorDireito = analogRead(sensorInferiorDireito);
  int leituraInferiorEsquerdo = analogRead(sensorInferiorEsquerdo);

  int tolerancia = 90;

  int mediaSuperior = (leituraSuperiorDireito + leituraSuperiorEsquerdo) / 2;
  int mediaInferior = (leituraInferiorDireito + leituraInferiorEsquerdo) / 2;

  int mediaDireita = (leituraSuperiorDireito + leituraInferiorDireito) / 2;
  int mediaEsquerda = (leituraSuperiorEsquerdo + leituraInferiorEsquerdo) / 2;

  int diferencaSupInf = mediaSuperior - mediaInferior;
  int diferencaDirEsq = mediaDireita - mediaEsquerda;

  if(abs(diferencaSupInf) > tolerancia){
    if(mediaSuperior > mediaInferior){
      posicaoY = --posicaoY;
      if(posicaoY < limitiMinimoY){
        posicaoY = limitiMinimoY;
      }
    }
    else /*if(mediaInferior > mediaSuperior)*/{
      posicaoY = ++posicaoY;
      if(posicaoY > limitiMaximoY){
        posicaoY = limitiMaximoY;
      }
    }
    servoy.write(posicaoY);
  }

  if(abs(diferencaDirEsq) > tolerancia){
    if(mediaDireita > mediaEsquerda){
      posicaoX = ++posicaoX;
      if(posicaoX > limitiMaximoX){
        posicaoX = posicaoX = limitiMaximoX;
      }
    }
    else /*if(mediaEsquerda > mediaDireita)*/{
      posicaoX = --posicaoX;
      if(posicaoX <  limitiMinimoX){
        posicaoX = posicaoX = limitiMinimoX;
      }
    }
    servox.write(posicaoX);
  }
  //delay(10);
}
